<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Educational RPI4 OS: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Educational RPI4 OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Great resource: <a href="https://github.com/s-matyukevich/raspberry-pi-os/tree/master">https://github.com/s-matyukevich/raspberry-pi-os/tree/master</a> This got me started on baremetal dev on the RPI</p>
<p >Educational project! Adapted for RPI3/RPI4</p>
<p >Includes a custom bluetooth host stack written by me. Can be found in this repo: <a href="https://github.com/Akashem06/RPI_Bluetooth">https://github.com/Akashem06/RPI_Bluetooth</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Getting Started</h1>
<p >Install tools in either WSL or Linux</p>
<p >sudo apt install qemu-system-arm</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Learnings</h1>
<p >Major debug learning I had throughout this project. I think these are the most valuable experiences.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
OS Scheduler hard faulting after updating the link register during context switch (Return address, so it will be the next line of code to run).</h2>
<h4><a class="anchor" id="autotoc_md4"></a>
What helped:</h4>
<p >Register dumping when I hard fault. Helpful to see x19-x28 + Stack pointer + program counter. Lower registers are mostly scratch registers that aren't too helpful :( Dumping these also helped:</p><ul>
<li>esr_el1: This register provides the error code for hard faulting (The cause of exception).<ul>
<li>Bits [31:26] - Exception Class (EC): Indicates type of violation(e.g., data abort, instruction abort, illegal execution).</li>
<li>Bits [24:0] - Instruction-Specific Syndrome (ISS): Extra information about the exception, such as details about the memory access that caused the fault.</li>
</ul>
</li>
<li>elr_el1: This register holds the return address after completing the exception. Hence e**lr**, its a link register.</li>
<li>far_el1: Holds the faulting Virtual Address for all sync instructions, abort exceptions, data abort exceptions, and PC alignment fault exceptions. Since I did not have an MMU setup during this process, this was 0.</li>
</ul>
<h4><a class="anchor" id="autotoc_md5"></a>
Debug Session:</h4>
<p >Debug logs: ERROR CAUGHT: SYNC_INVALID_EL1h - 4. ESR: 33554432 Address: 11968 Fault addr_reg: 0, stack pointer: 4202240 REG_NUMBER: 7, VALUE: 588976452 REG_NUMBER: 8, VALUE: 4198496 REG_NUMBER: 8, VALUE: 4198496 REG_NUMBER: 9, VALUE: 4202496 REG_NUMBER: 19, VALUE: 548144 REG_NUMBER: 20, VALUE: 0 REG_NUMBER: 21, VALUE: 0 REG_NUMBER: 22, VALUE: 0 REG_NUMBER: 23, VALUE: 0 REG_NUMBER: 24, VALUE: 0 REG_NUMBER: 25, VALUE: 0 REG_NUMBER: 26, VALUE: 0 REG_NUMBER: 27, VALUE: 0 REG_NUMBER: 28, VALUE: 0 REG_NUMBER: 29, VALUE: 4202224 REG_NUMBER: 30, VALUE: 530620</p>
<p >My custom log library doesn't support hex at the time of this fix so... Had to deal with decimal values. ESR = 0x2000000. So the EC = 0x20: This means Instruction Abort in lower EL. The fault occurred because of an instruction abort while in a lower Exception Level (EL1 in this case).</p>
<p >SYNC_INVALID_EL1h is the most helpful. This exception is thrown when a synchronous error occurs in EL1.</p>
<p >SYNC = Exception is related to the instruction flow. Fault caused by executing an invalid instruction, an access to an unmapped memory location, etc. Synchronous exceptions happen in direct response to program execution, unlike asynchronous exceptions (like interrupts), which occur independently of the current instruction flow.</p>
<p >INVALID = I messed up :(</p>
<p >EL1h = Happened in EL1 (Which I set in the boot process). the 'h' means we are in handler mode.</p>
<p >Ok so it seems to be an invalid memory access! But the addresses are all correct, I checked with debug statements. The exception link register (elr_el1) is holding the correct function address, but it does seem fishy.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
My misconception:</h4>
<p >I was using relative function address rather than the absolute.</p>
<p >The stack pointer is set to LOW_MEMORY during bootup. This is at 4MB. When accessing the location of our new task's function, it is relative to our stack pointer. This would be fine in the case where the function is located in a memory region that can be reached with a relative address, such as within a small offset range from the current position of the stack pointer.</p>
<p >However, in cases where the function address is far from the stack pointer (e.g., if it's located in a different section of memory such as .text or .rodata), using a relative address would cause incorrect memory access, resulting in an instruction abort (as in this case). This is because the relative address calculation wouldn't be sufficient to access the correct memory location for the function.</p>
<p >By default, relative addressing in ARM assembly (with LDR) calculates offsets relative to the program counter or the current instruction, which can be problematic when jumping between different memory regions.</p>
<h4><a class="anchor" id="autotoc_md7"></a>
The fix:</h4>
<p >Fix 1 (Implemented): Use ADR rather than LDR to load the address of the function. This fetches the absolute memory address. Fix 2: Add LOW_MEMORY to the obtained memory address using LDR and ADD in assembly.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
Key concepts:</h4>
<p >Exception handling. Memory access. Context switching.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
ROData not being found at the correct memory location</h2>
<p >I forgot to set the location counter in the linkerscript. This is essential. The kernel load address for AArch64 is at 0x80000. This means everything compiled and flashed is at an offset + 0x80000. After adding this to the linkerscript I was able to correctly read the rodata. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
